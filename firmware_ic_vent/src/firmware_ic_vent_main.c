//=========================================================
// src/firmware_ic_vent_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8BB3_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
#include "pin_names.h"
#include <STRING.H>
#include <STDIO.H>
#include <MATH.H>
#include "timers.h"
uint8_t TASK_select = 0;
uint8_t LID_select = 0;
uint8_t last_sw_lid_state = 1;
uint8_t last_sw_vent_state = 1;
bit swlidpressed = 0;
bit swventpressed1 = 0;
bit swventpressed = 0;
uint8_t lidcalibstate = 0;

bit button_state = 0;
bit button_state1 = 0;
bit errorLID = 0;
bit errorVENT = 0;

#define TASK1				 	0
#define TASK2				 	1
#define TASK3					2
#define TASK4					3
#define TASK5					4

#define LID_OPEN				1
#define LID_OPENING				2
#define LID_OPENING_STARTING	3
#define LID_CLOSING_STARTING	4
#define LID_CLOSING				5
#define LID_CLOSED				6
#define LID_ERROR				7
#define LID_ERROR_RECALIBRATE 	8
#define LID_MOTOR_OPEN 			1
#define LID_MOTOR_CLOSE			0
#define LID_MOTOR_STOP			2
#define LID_MOTOR_BRAKE			3

#define VENT_STOPPED				0
#define VENT_OUT					1
#define VENT_IN 					2
#define VENT_STOPPING				3
#define VENT_IN_STARTING			4
#define VENT_OUT_STARTING			5
#define VENT_ERROR					6

#define VENT_MOTOR_IN 			1
#define VENT_MOTOR_OUT			0
#define VENT_MOTOR_STOP			2
#define VENT_MOTOR_BRAKE		3

uint8_t lidstate = LID_OPEN;
uint8_t ventstate = VENT_STOPPED;
uint32_t xdata checkTimer1 = 0;
uint32_t xdata checkTimer2 = 0;
uint32_t xdata checkTimer3 = 0;
uint32_t xdata checkTimer4 = 0;
uint32_t xdata checkTimer5 = 0;
uint32_t xdata timerlid = 0;
uint32_t xdata timervent = 0;
uint32_t xdata timer1 = 0;
uint32_t xdata timer2 = 0;

extern uint32_t newKey;
extern uint32_t oldKey;
// $[Generated Includes]
// [Generated Includes]$

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup(void) {
	// $[SiLabs Startup]
	// [SiLabs Startup]$
}

//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
void init_ir_receiver() {
	/*	// Stop timer3 and clear overflow flag
	 TMR3CN0 &= ~TMR3CN0_TR3__BMASK;
	 TMR3CN0 &= ~TMR3CN0_TF3H__BMASK;
	 TMR3CN0 &= ~TMR3CN0_TF3L__BMASK;

	 // Set timer3 reload value to maximum

	 TMR3CN0 |= TMR3CN0_TR3__RUN;
	 TMR3 = 0;
	 */

	TH0 = 208;  // Reload the timer value for 1ms Delay 0xB0E
	TL0 = 198;

	TCON_TR0 = 1;   // Start the Timer
	IE_ET0 = 1;       // Enable the Timer0 Interrupt

	TCON_IT0 = 1;       // Configure INT0 falling edge interrupt
	IE_EX0 = 1;       // Enable the INT0 External Interrupt

	IE_EA = 1;       // Enable the Global Interrupt bit

}
void setlidmotor(int state) {
	switch (state) {
	case LID_MOTOR_OPEN: {
		ML_2 = 0;
		ML_1 = 1;

		break;

	}
	case LID_MOTOR_CLOSE: {
		ML_2 = 1;
		ML_1 = 0;

		break;

	}
	case LID_MOTOR_STOP: {
		ML_2 = 0;
		ML_1 = 0;

		break;

	}
	case LID_MOTOR_BRAKE: {
		ML_2 = 1;
		ML_1 = 1;

		break;

	}
	}
}

void setventmotor(int state) {
	switch (state) {
	case VENT_MOTOR_IN: {
		MV_2 = 0;
		MV_1 = 0;

		break;

	}
	case VENT_MOTOR_OUT: {
		MV_2 = 1;
		MV_1 = 0;

		break;

	}
	case VENT_MOTOR_STOP: {
		MV_2 = 1;
		MV_1 = 1;

		break;

	}
	case VENT_MOTOR_BRAKE: {
		MV_2 = 0;
		MV_1 = 1;

		break;

	}
	}
}

int main(void) {
	// Call hardware initialization routine
	enter_DefaultMode_from_RESET();
	init_ir_receiver();
	currentMillis = millis;
	LED_LID = 1;
	LED_VENT = 1;
	LED_RAIN = 1;
	//lid motor stopped
	ML_2 = 0;
	ML_1 = 0;

	//setlidmotor(LID_MOTOR_CLOSE);

	//fan motor stopped
	MV_2 = 1;
	MV_1 = 1;

	swlidpressed = 1;

	while (true) {

		switch (TASK_select) {

		case TASK1: {

			if (millis - checkTimer1 > 100) {

				checkTimer1 = millis;

				switch (lidstate) {
				case LID_CLOSED: //poklopac zatvoren
				{
					if (swlidpressed) {
						swlidpressed = 0;
						//blinkingLID=1;
						lidstate = LID_OPENING_STARTING;
						setlidmotor(LID_MOTOR_OPEN);
						timerlid = millis;

					}

					break;
				}
				case LID_CLOSING_STARTING: { //ignore CS
					if (millis - timerlid > 200) {
						lidstate = LID_CLOSING;
						timerlid = millis;

					}

					break;
				}
				case LID_CLOSING: {
					if (swlidpressed) {
						swlidpressed = 0;
						lidstate = LID_CLOSED;
						setlidmotor(LID_MOTOR_STOP);
						break;

					}
					if (millis - timerlid > 20000 && !ML_CS) {
						// zatvaranje traje predugo a nemamo CS
						setlidmotor(LID_MOTOR_STOP);
						swlidpressed = 0;
						lidstate = LID_ERROR;
					} else if (ML_CS) {
						setlidmotor(LID_MOTOR_STOP);
						lidstate = LID_CLOSED;
						swlidpressed = 0;
					}

					break;
				}
				case LID_OPENING_STARTING: { //ignore CS
					if (millis - timerlid > 200) {
						lidstate = LID_OPENING;
						timerlid = millis;

					}

					break;
				}
				case LID_OPENING: { //scan current sense and time opening // also button will stop motor
					if (swlidpressed) {
						swlidpressed = 0;
						lidstate = LID_OPEN;
						setlidmotor(LID_MOTOR_STOP);
						break;

					}
					if (millis - timerlid > 20000 && !ML_CS) {
						// opening too long go to recalibrate
						setlidmotor(LID_MOTOR_STOP);
						swlidpressed = 0;
						lidstate = LID_ERROR_RECALIBRATE;
					}else if (millis - timerlid < 15000 && ML_CS) { //opening shorter than usual - goto recalibrate
						setlidmotor(LID_MOTOR_STOP);
						swlidpressed = 0;
						lidstate = LID_ERROR_RECALIBRATE;
					}


					else if (ML_CS){ //we have openned stop motor {
						setlidmotor(LID_MOTOR_STOP);
						lidstate = LID_OPEN;
						swlidpressed = 0;
					}

					break;
				}

				case LID_OPEN: {
					if (swlidpressed) {
						swlidpressed = 0;
						//	LED_LID = 1;
						if (ventstate == VENT_OUT || ventstate == VENT_IN || ventstate == VENT_OUT_STARTING || ventstate == VENT_IN_STARTING) {
							ventstate = VENT_STOPPING;
							setventmotor(VENT_MOTOR_BRAKE);
						}
						lidstate = LID_CLOSING_STARTING;
						setlidmotor(LID_MOTOR_CLOSE);
						timerlid = millis;

					}

					break;
				}
				case LID_ERROR: {
					if (swlidpressed) {

						swlidpressed = 0;
						lidstate = LID_CLOSING_STARTING;
						setlidmotor(LID_MOTOR_CLOSE);

					}

					break;

				}
				case LID_ERROR_RECALIBRATE:
				{
					switch (lidcalibstate) {

												case 0: { // lets try to close lid

												swlidpressed = 0;
												lidcalibstate = 1;
												setlidmotor(LID_MOTOR_CLOSE);
												timerlid = millis;
												break;


												}
												case 1: {

													if (millis - timerlid > 200) {
														lidcalibstate = 2;
														timerlid = millis;

														}

													 break;


												}
												case 2: {

													if (millis - timerlid > 20000 && !ML_CS) {
													// zatvaranje traje predugo a nemamo CS u trajnoj smo greski;
														swlidpressed = 0; //ponisti gumb
													setlidmotor(LID_MOTOR_STOP);
													lidstate = LID_ERROR;
													} else if (ML_CS) { //zatvorili smo - treba probati otvoriti
													setlidmotor(LID_MOTOR_STOP);
													lidcalibstate = 3;
													timerlid = millis;
													}

													 break;


												}
												case 3: { // lets try to open lid

												swlidpressed = 0;
												lidcalibstate = 4;
												setlidmotor(LID_MOTOR_OPEN);
												timerlid = millis;
												break;


												}

												case 4: {

													if (millis - timerlid > 200) {
														lidcalibstate = 5;
														timerlid = millis;

														}

													 break;


												}
												case 5: {

													if (millis - timerlid > 20000 && !ML_CS) {
														// opening too long go to recalibrate
														setlidmotor(LID_MOTOR_STOP);
														swlidpressed = 0;
														lidcalibstate = 10; //nismo uspjeli otvoriti zatvori i odi u grešku
													}else if (millis - timerlid < 15000 && ML_CS) { //opening shorter - zatvori i greška
														setlidmotor(LID_MOTOR_STOP);
														swlidpressed = 0;
														lidcalibstate = 10; //nismo uspjeli otvoriti nešto je zapelo - idi u grepjku
													}


													else if (ML_CS){ // otvorili smo ... sad zatvaramo i ako uspijemo zatvorit sve je ok.
														setlidmotor(LID_MOTOR_STOP);
														lidcalibstate = 6;
														swlidpressed = 0;
													}

													 break;


												}
												case 6: { // lets try to close lid

												swlidpressed = 0;
												lidcalibstate = 7;
												setlidmotor(LID_MOTOR_CLOSE);
												timerlid = millis;
												break;


												}
												case 7: {

													if (millis - timerlid > 200) {
														lidcalibstate = 8;
														timerlid = millis;

														}

													 break;


												}
												case 8: {

													if (millis - timerlid > 20000 && !ML_CS) {
													// zatvaranje traje predugo a nemamo CS u trajnoj smo greski;
														swlidpressed = 0; //ponisti gumb
													setlidmotor(LID_MOTOR_STOP);
													lidstate = LID_ERROR;
													lidcalibstate = 0;
													}else if (millis - timerlid < 15000 && ML_CS) { //opening shorter - zatvori i greška
														setlidmotor(LID_MOTOR_STOP);
														swlidpressed = 0;
														lidcalibstate = 0; //nismo uspjeli otvoriti nešto je zapelo - idi u grepjku
														lidstate = LID_ERROR;
													}
													else if (ML_CS) { //zatvorili smo do kraja
													setlidmotor(LID_MOTOR_STOP);
													lidcalibstate = 0;
													timerlid = millis;
													lidstate = LID_CLOSED;

													}

													 break;


												}
												case 10: { // lets try to close lid

												swlidpressed = 0;
												lidcalibstate = 11;
												setlidmotor(LID_MOTOR_CLOSE);
												timerlid = millis;
												break;


												}
												case 11: {

													if (millis - timerlid > 200) {
														lidcalibstate = 12;
														timerlid = millis;

														}

													 break;


												}
												case 12: {

													if (millis - timerlid > 20000 && !ML_CS) {
													// zatvaranje traje predugo a nemamo CS u trajnoj smo greski;
														swlidpressed = 0; //ponisti gumb
													setlidmotor(LID_MOTOR_STOP);
													lidstate = LID_ERROR;
													lidcalibstate = 0;}
													else if (ML_CS) { //zatvorili smo do kraja
													setlidmotor(LID_MOTOR_STOP);
													lidcalibstate = 0;
													timerlid = millis;
													lidstate = LID_ERROR;

													}

													 break;


												}

												break;

										}

				}


				}
			}

			TASK_select++;
			break;
		}
		case TASK2: { //check rain sensor

			if (millis - checkTimer1 > 100) {
				/*	if (blinkingLID) LED_RAIN = !LED_RAIN;
				 if (blinkingVENT) LED_RAIN = !LED_RAIN;
				 */
				checkTimer1 = millis;

				switch (ventstate) {
				case VENT_STOPPED: {
					if (swventpressed) {
						swventpressed = 0;
						//LED_VENT = 1;
						//blinkingVENT=1;
						ventstate = VENT_OUT_STARTING;
						setventmotor(VENT_MOTOR_OUT);
						timervent = millis;

					}
					if (swventpressed1) {
											swventpressed1 = 0;
											//LED_VENT = 1;
											//blinkingVENT=1;
											ventstate = VENT_IN_STARTING;
											setventmotor(VENT_MOTOR_IN);
											timervent = millis;

										}


					break;
				}
				case VENT_OUT_STARTING: {
					{ //ignore CS
						if (millis - timervent > 1000) {
							ventstate = VENT_OUT;
							timervent = millis;

						}

						break;
					}

					break;
				}
				case VENT_IN_STARTING: {
									{ //ignore CS
										if (millis - timervent > 1000) {
											ventstate = VENT_IN;
											timervent = millis;

										}

										break;
									}

									break;
								}
				case VENT_OUT: {
					if (swventpressed) {
						swventpressed = 0;
						ventstate = VENT_STOPPING;
						setventmotor(VENT_MOTOR_BRAKE);

					} else if (MV_CS) {

						setventmotor(VENT_MOTOR_STOP);
						ventstate = VENT_ERROR;
						swventpressed = 0;

					}

					break;
				}
				case VENT_STOPPING: {
					if (millis - timervent > 200) {

						ventstate = VENT_STOPPED;
						setventmotor(VENT_MOTOR_STOP);
						swventpressed = 0;
						timervent = millis;

					}

					break;
				}
				case VENT_IN: {
									if (swventpressed) {
										swventpressed = 0;
										ventstate = VENT_STOPPING;
										setventmotor(VENT_MOTOR_BRAKE);

									}
									else if (swventpressed1){
										swventpressed1 = 0;
										ventstate = VENT_STOPPING;
										setventmotor(VENT_MOTOR_BRAKE);
									}
									else if (MV_CS) {

										setventmotor(VENT_MOTOR_STOP);
										ventstate = VENT_ERROR;
										swventpressed = 0;
										swventpressed1 = 0;

									}

									break;
								}

				case VENT_ERROR: {
					if (swventpressed) {

						swventpressed = 0;

						ventstate = VENT_OUT_STARTING;
						setventmotor(VENT_MOTOR_OUT);

					}

					break;

				}

				}
			}

			TASK_select++;
			break;
		}
		case TASK3: {
			if (millis - checkTimer3 > 10) {
				button_state = SW_LID;

				if (!button_state && last_sw_lid_state) {
					swlidpressed = 1;

				}

				// Update last button state
				last_sw_lid_state = button_state;

				button_state1 = SW_VENT;

				if (!button_state1 && last_sw_vent_state) {
					if (lidstate == LID_OPEN || lidstate == LID_OPENING) swventpressed = 1;
				}

				// Update last button state
				last_sw_vent_state = button_state1;

				checkTimer3 = millis;
				//LED_LID = !LED_LID;

			}
			TASK_select++;
			break;
		}
		case TASK4: {

			if (millis - checkTimer2 > 2) {

				if (ML_CS && lidstate!=LID_ERROR) {

					LED_LID = 0;

				} else if (lidstate!=LID_ERROR) {
					LED_LID = 1;

				}

				if (MV_CS && ventstate!=VENT_ERROR) {

					LED_VENT = 0;

				} else if (ventstate!=VENT_ERROR) {
					LED_VENT = 1;

				}

				checkTimer2 = millis;

			}
			if (checkTimer4 - millis > 1000) {

				if (!RAIN_IN) {
					LED_RAIN = 0;	// rain detected
					if (ventstate == VENT_OUT || ventstate == VENT_IN) {
						ventstate = VENT_STOPPED;
						setventmotor(VENT_MOTOR_STOP);
					}

					if (lidstate != LID_CLOSED && lidstate != LID_CLOSING
							&& lidstate != LID_CLOSING_STARTING) {
						lidstate = LID_CLOSING_STARTING;
						setlidmotor(LID_MOTOR_CLOSE);
						timerlid = millis;
					}

				} else {
					LED_RAIN = 1;
				}
				if (lidstate == LID_CLOSED ) {
					if (ventstate == VENT_OUT || ventstate == VENT_IN){
						swventpressed = 0;
						ventstate = VENT_STOPPING;
						setventmotor(VENT_MOTOR_BRAKE);

					}
				}
				checkTimer4 = millis;

			}

			TASK_select++;
			break;
		}
		case TASK5: {

			if (millis - checkTimer5 > 500) {

				checkTimer5 = millis;
				if (lidstate == LID_ERROR) {
					LED_LID = !LED_LID;

				}

				if (ventstate == VENT_ERROR) {
					LED_VENT = !LED_VENT;
				}

			}

			TASK_select++;
			break;
		}
		default: {

			if (newKey == 0x20df40bf)  //volume up
				{

					oldKey = newKey;
					newKey = 0;
					if (!swlidpressed && (lidstate == LID_CLOSED)  ) swlidpressed = 1;



			}
			if (newKey == 0x20dfc03f)  //volume down
							{

								oldKey = newKey;
								newKey = 0;
								if (!swlidpressed && (lidstate == LID_OPEN)   ){
									swlidpressed = 1;
									if (!swventpressed && (ventstate == VENT_IN || ventstate == VENT_OUT || ventstate==VENT_IN_STARTING || ventstate ==VENT_IN_STARTING )){
										swventpressed = 1;

									}

								}



						}
			else if (newKey == 0x20df00ff) //Channel up
			{

				oldKey = newKey;
				newKey = 0;

				if (!swventpressed && (ventstate == VENT_STOPPED) && (lidstate == LID_OPEN || lidstate == LID_OPENING ) ) swventpressed = 1;


		}
			else if (newKey == 0x20df807f) //0x20df807f - channel down
					{

						oldKey = newKey;
						newKey = 0;

						if (!swventpressed && (ventstate == VENT_OUT || ventstate == VENT_IN ) && (lidstate == LID_OPEN || lidstate == LID_OPENING )  ) swventpressed = 1;


				}
			else if (newKey == 0x20df14eb) //0x20df807f - back button
							{

								oldKey = newKey;
								newKey = 0;

								if (!swventpressed1 && (ventstate == VENT_STOPPED && (lidstate == LID_OPEN || lidstate == LID_OPENING ) )  ) swventpressed1 = 1;


						}
			else if (newKey == 0x20df10ef)  //power button
						{

							oldKey = newKey;
							newKey = 0;

													if (!swlidpressed && (lidstate == LID_CLOSED)  ) swlidpressed = 1;
													if (!swventpressed && (ventstate == VENT_STOPPED )  ) swventpressed = 1;


					}
			else if (newKey == 0x20dfc23d)  //menu button
								{

									oldKey = newKey;
									newKey = 0;

									if (!swlidpressed && (lidstate == LID_OPEN)  ) swlidpressed = 1;
									if (!swventpressed && (ventstate == VENT_OUT )  ) swventpressed = 1;


							}




			//0x20df00ff - channel up
			//0x20df807f - chanel down
			//0x20df02fd - arrow up
			//0x20df827d - arrow down
			//0x20df609f - arrow right
			//0x20df22dd - ok
			//0x20dfc23d - menu
			//0x20df14eb - back
			TASK_select = 0;
			break;
		}
		}

	}
}
// $[Generated Run-time code]
// [Generated Run-time code]$

